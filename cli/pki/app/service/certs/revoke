#!/usr/bin/env bash
set -e
trap "exit" INT

YQ=./.bin.pki/yq

SERVICE_CERT_BLUEPRINT=$1
CLUSTER_INVENTORY=$2
CA_SERVER=$3
CA_TARGET=$4

function service-certs-revoke-validate {
    local INVENTORY_FILE=~/.host-inventory/inventory.d/${CLUSTER_INVENTORY}
    local CURRENT_DIRECTORY=$(pwd)
    local BLUEPRINT_DIRECTORY=${CURRENT_DIRECTORY}/pki/blueprint
    local BLUEPRINT_FILE=${BLUEPRINT_DIRECTORY}/certs/${CLUSTER_INVENTORY}/${SERVICE_CERT_BLUEPRINT}/spec.yml

    if [[ ! -f "${INVENTORY_FILE}" ]]; then
        echo -e "${RED}[ERROR]${NC} ${YELLOW}${clusterInventory}${NC} cluster inventory not found. Expected on: ${RED}[${inventoryFile}]${NC}"
        echo -e "Try to run ${YELLOW}./pkictl inventory setup${NC} to setup inventories needed for pkictl"
        exit 1
    fi

    if [[ ! -f "${BLUEPRINT_FILE}" ]]; then
        echo -e "${RED}[ERROR]${NC} ${YELLOW}${BLUEPRINT_FILE}${NC} blueprint file not found. Expected on: ${RED}[${BLUEPRINT_FILE}]${NC}"
        exit 1
    fi
}

function validate-revoker {
    local GITHUB_AUTH_USERNAME=$1
    local GITHUB_AUTH_TOKEN=$2

    REVOKER_DB_GITHUB_REPOSITORY=$($YQ r pki/blueprint/config.yml "pkictl.db.github.approver_db_github_repository")
    REVOKER_DB_FILE=$($YQ r pki/blueprint/config.yml "pkictl.db.github.approver_db_file")

    REVOKER_DB_TARGET_CLONE_DIRECTORY=$HOME/.pkictl/.revoker
    rm -rf $REVOKER_DB_TARGET_CLONE_DIRECTORY

    echo ""
    echo -e "${GREEN}[PKICTL]${NC} Verifying revoker list. Cloning revoker repository ${YELLOW}${REVOKER_DB_GITHUB_REPOSITORY}${NC}"
    AUTO_GITHUB_REVOKER=$(expect -c "
        set timeout 5
        spawn git clone ${REVOKER_DB_GITHUB_REPOSITORY} ${REVOKER_DB_TARGET_CLONE_DIRECTORY}
        expect \"Cloning into '' ...\"
        expect \"Username for 'https://github.com':\"
        send \"${GITHUB_AUTH_USERNAME}\r\"
        expect \"Password for 'https://${GITHUB_AUTH_USERNAME}@github.com':\"
        send \"${GITHUB_AUTH_TOKEN}\r\"
        set timeout 10
        expect eof
    ")
    echo "$AUTO_GITHUB_REVOKER"

    if [[ ! -f "${REVOKER_DB_TARGET_CLONE_DIRECTORY}/${REVOKER_DB_FILE}" ]]; then
        echo -e "${RED}[ERROR]${NC} An error occurred when trying to verify account ${YELLOW}${GITHUB_AUTH_USERNAME}${NC} permission to issue certificate. Aborting..."
        exit 1
    fi

    REVOKER_USER=$(cat ${REVOKER_DB_TARGET_CLONE_DIRECTORY}/${REVOKER_DB_FILE} | grep -w "${GITHUB_AUTH_USERNAME}")
    if [[ "${REVOKER_USER}" == "" || -z "${REVOKER_USER}" ]]; then
        echo -e "${RED}[ERROR]${NC} An error occurred, account ${YELLOW}${GITHUB_AUTH_USERNAME}${NC} has no permission to issue certificate. Aborting..."
        exit 1
    fi
    
    rm -rf ${REVOKER_DB_TARGET_CLONE_DIRECTORY}
}

function cleanup-directory {
    echo -e "${GREEN}[PKICTL]${NC} Please wait a bit.. Cleaning up..."
    rm -rf $@
}

function retrieve-certificate-database {
    local TEMP_DB_DIR=$1
    local TEMP_DB_FILE=$2
    local INVENTORY_FILE=~/.host-inventory/inventory.d/${CLUSTER_INVENTORY}
    local PKICTL_DIRECTORY=/usr/share/pki

    $ANSIBLE_PLAYBOOK pki/playbook/pki-service-certs-retrieve-cert-db.yml \
        -i "${INVENTORY_FILE}" \
        -e "ca_server=${CA_SERVER}" \
        -e "ca_target=${CA_TARGET}" \
        -e "temp_db_dir=${TEMP_DB_DIR}" \
        -e "temp_db_file=${TEMP_DB_FILE}" \
        -e "cert_name=${SERVICE_CERT_BLUEPRINT}" \
        -e "pkictl_directory=${PKICTL_DIRECTORY}" 
}

function format-cert-timestamp {
    TIMESTAMP=$1
    
    local YEAR=""
    local MONTH=""
    local DATE=""
    local HOUR=""
    local MINUTE=""
    local SECOND=""

    local TIMESTAMP_ELEMENTS=$(echo -e "$1" | fold -w2 | xargs echo)
    IFS=" " read -ra TIMESTAMP_ELEMENT_LIST <<< ${TIMESTAMP_ELEMENTS}
    for index in ${!TIMESTAMP_ELEMENT_LIST[@]}
    do
        case ${index} in
            0)
                YEAR=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            1)
                MONTH=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            2)
                DATE=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            3)
                HOUR=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            4)
                MINUTE=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            5)
                SECOND=${TIMESTAMP_ELEMENT_LIST[${index}]};;
            *)
                break;;
        esac
    done

    echo -e "${DATE}/${MONTH}/${YEAR} - ${HOUR}:${MINUTE}:${SECOND}"
}

function validate-crt-index {
    MAX_INDEX=$1
    TEST_INDEX=$2
    VALIDATED_CRT_TO_REVOKE=$3

    if [[ $VALIDATED_CRT_TO_REVOKE == *"${TEST_INDEX}"* ]]; then
        echo -e "invalid"
        return 0
    fi

    if [[ ! "${TEST_INDEX}" =~ ^[0-9]+$ ]]; then
        echo -e "invalid"
        return 0
    fi

    if [[ "${TEST_INDEX}" =~ ^0[0-9]+$ ]]; then
        echo -e "invalid"
        return 0
    fi

    if (($TEST_INDEX>=0 && $TEST_INDEX<=$MAX_INDEX)); then
        echo -e "valid"
        return 0
    else
        echo -e "invalid"
        return 0
    fi
}

function revoke-certificate {
    CERTS=$1

    local INVENTORY_FILE=~/.host-inventory/inventory.d/${CLUSTER_INVENTORY}
    local PKICTL_DIRECTORY=/usr/share/pki
    local REVOKE_BY="serial"

    if [[ "${CLUSTER_INVENTORY}" == "local" ]]; then
        echo -ne "\n${GREEN}[PKICTL]${NC} "
        $ANSIBLE_PLAYBOOK pki/playbook/pki-certs-revoke.yml \
            -i "${INVENTORY_FILE}" \
            -e "ca_server=${CA_SERVER}" \
            -e "ca_target=${CA_TARGET}" \
            -e "pkictl_directory=${PKICTL_DIRECTORY}" \
            -e "certs_to_revoke=${CERTS}" \
            -e "revoke_by=${REVOKE_BY}" \
            --ask-become-pass
    else
        $ANSIBLE_PLAYBOOK pki/playbook/pki-certs-revoke.yml \
            -i "${INVENTORY_FILE}" \
            -e "ca_server=${CA_SERVER}" \
            -e "ca_target=${CA_TARGET}" \
            -e "pkictl_directory=${PKICTL_DIRECTORY}" \
            -e "certs_to_revoke=${CERTS}" \
            -e "revoke_by=${REVOKE_BY}"
    fi
}

function service-certs-revoke-execute {
    local INVENTORY_FILE=~/.host-inventory/inventory.d/${CLUSTER_INVENTORY}

    echo -e "${GREEN}[PKICTL]${NC} To revoke certificate, we will need to authenticate you using your GitHub identity and making sure that you are the authorized person to revoke the certificate.${NC}"
    echo -e "${GREEN}[PKICTL]${NC} Please use your ${YELLOW}GITHUB_USERNAME${NC} as your GitHub username and your ${YELLOW}GITHUB_PERSONAL_ACCESS_TOKEN${NC} (with ${YELLOW}repo permission${NC}) when prompted to enter Github Password"

    echo -ne "${GREEN}[PKICTL]${NC} Enter your GitHub Username: "
    read GITHUB_AUTH_USERNAME
    echo -ne "${GREEN}[PKICTL]${NC} Enter your GitHub Personal Access Token: "
    read -s GITHUB_AUTH_TOKEN

    if [[ "${CA_SERVER}" != "local-ca" ]]; then
        validate-revoker $GITHUB_AUTH_USERNAME $GITHUB_AUTH_TOKEN
    else
        echo -e ""
        echo -e "${GREEN}[PKICTL]${NC} Skipping revoker validation -- for ${YELLOW}local-ca${NC}"
    fi

    echo -e "${GREEN}[PKICTL]${NC} Revoker: ${YELLOW}${GITHUB_AUTH_USERNAME}${NC}, CA Server: ${YELLOW}$CA_SERVER${NC}"
    echo -e "${GREEN}[PKICTL]${NC} Start revoking certificate..."

    local CURRENT_DIRECTORY=$(pwd)
    local CERTIFICATE_DATABASE_COPY_DIRECTORY=${CURRENT_DIRECTORY}/.tmp.pki/ca.db
    local CERTIFICATE_DATABASE_COPY_FILE=${CERTIFICATE_DATABASE_COPY_DIRECTORY}/${SERVICE_CERT_BLUEPRINT}.db

    cleanup-directory ${CERTIFICATE_DATABASE_COPY_DIRECTORY}

    retrieve-certificate-database ${CERTIFICATE_DATABASE_COPY_DIRECTORY} ${CERTIFICATE_DATABASE_COPY_FILE}

    IS_CHOOSING_CRT=1
    while [[ $IS_CHOOSING_CRT == 1 ]]; do
        echo -e "${GREEN}[PKICTL]${NC} ${YELLOW}Which certificate do you want to revoke for this service?${NC}"
        echo -e "${GREEN}[PKICTL]${NC} ${YELLOW}=====================================================================${NC}"
        echo -e ""
        
        local CERT_SERIAL_NUMBERS=$(cat ${CERTIFICATE_DATABASE_COPY_FILE} | awk -F ',' '{print $1}' | xargs echo)
        local CERT_EXPIRY_TIMESTAMPS=$(cat ${CERTIFICATE_DATABASE_COPY_FILE} | awk -F ',' '{print $2}' | xargs echo)
        
        IFS=" " read -ra SERIAL_NUMBER_LIST <<< ${CERT_SERIAL_NUMBERS}
        IFS=" " read -ra EXPIRY_LIST <<< ${CERT_EXPIRY_TIMESTAMPS}
        printf "%5s %15s %25s\n" "#" "Serial Number" "Valid Until" 

        for index in "${!SERIAL_NUMBER_LIST[@]}"
        do
            TIMESTAMP_STRING=$(format-cert-timestamp ${EXPIRY_LIST[$index]: : -1})
            printf "%5s %15s %25s\n" "[${index}]" "0x${SERIAL_NUMBER_LIST[$index]}" "${TIMESTAMP_STRING}"
        done
        echo -e ""
        printf "%5s %s\n" "[L]" "Revoke all certificates, except the latest one"
        printf "%5s %s\n" "[A]" "Revoke all certificates"
        printf "%5s %s\n" "[C]" "Cancel"
        echo -e ""
        echo -e "${GREEN}[PKICTL]${NC} ${YELLOW}=====================================================================${NC}"
        echo -e "${GREEN}[PKICTL]${NC} Please type the index number for the next prompted input"
        echo -e "${GREEN}[PKICTL]${NC} For revoking mutliple certificates, please separate the index number with comma and without space ${YELLOW}(e.g. 0,1,2)${NC}"
        echo -e "${GREEN}[PKICTL]${NC} You can type ${YELLOW}L${NC} to revoke all certificates, ${YELLOW}except the latest one${NC} for this service"
        echo -e "${GREEN}[PKICTL]${NC} You can type ${YELLOW}A${NC} to revoke all certificates for this service"
        echo -e "${GREEN}[PKICTL]${NC} You can type ${YELLOW}C${NC} to cancel"
        echo -ne "${GREEN}[PKICTL]${NC} Enter the certificate index that you want to revoke: "
        read CRT_TO_REVOKE_CHOICE

        MAX_INDEX=$((${#SERIAL_NUMBER_LIST[@]}-1))
        if [[ "$CRT_TO_REVOKE_CHOICE" =~ ^[Aa]$ ]];  then
            for i in $(seq 0 $MAX_INDEX)
            do
                CRT_TO_REVOKE="$CRT_TO_REVOKE,$i"
            done
            CRT_TO_REVOKE="${CRT_TO_REVOKE:1}"
        elif [[ "$CRT_TO_REVOKE_CHOICE" =~ ^[Ll]$ ]];  then
            if [[ $MAX_INDEX == 0 ]]; then
                EXCLUDE_LATEST=0
            else
                EXCLUDE_LATEST=$((${MAX_INDEX}-1))
            fi

            for i in $(seq 0 $EXCLUDE_LATEST)
            do
                CRT_TO_REVOKE="$CRT_TO_REVOKE,$i"
            done
            CRT_TO_REVOKE="${CRT_TO_REVOKE:1}"
        elif [[ "$CRT_TO_REVOKE_CHOICE" =~ ^[Cc]$ ]]; then
            echo -e "${GREEN}[PKICTL]${NC} ${YELLOW}Revoke operation has been cancelled${NC}"
            cleanup-directory $CERTIFICATE_DATABASE_COPY_DIRECTORY
            exit 0
        else
            CRT_TO_REVOKE=$CRT_TO_REVOKE_CHOICE
        fi

        if [[ -z "${CRT_TO_REVOKE}" || "${CRT_TO_REVOKE}" =~ ^[a-zA-Z]+$ ]]; then
            echo -e "${GREEN}[PKICTL]${NC} ${RED}No certificate to revoke. Aborting...${NC}"
            cleanup-directory $CERTIFICATE_DATABASE_COPY_DIRECTORY
            exit 1
        fi

        echo -e ""
        echo -e "${GREEN}[PKICTL]${NC} ${YELLOW}Certificate(s) to revoke:${NC}"
        VALIDATED_CRT_TO_REVOKE=""
        IFS="," read -ra CRT_INDEX <<< $CRT_TO_REVOKE
        for element in "${CRT_INDEX[@]}"
        do
            IS_INDEX_VALID=$(validate-crt-index $MAX_INDEX $element $VALIDATED_CRT_TO_REVOKE)
            if [[ "$IS_INDEX_VALID" == "valid" ]]; then
                TIMESTAMP_STRING=$(format-cert-timestamp ${EXPIRY_LIST[$element]: : -1})
                printf "%5s %15s %25s\n" "[${element}]" "0x${SERIAL_NUMBER_LIST[$element]}" "${TIMESTAMP_STRING}"
                VALIDATED_CRT_TO_REVOKE="$VALIDATED_CRT_TO_REVOKE,$element"
            fi
        done
        echo -ne "${GREEN}[PKICTL]${NC} Are you sure want to revoke the above certificates (y/N)? "
        read REVOKE_CONFIRMATION
        if [[ $REVOKE_CONFIRMATION =~ ^[Yy]$ ]]; then
            IS_CHOOSING_CRT=0
            break
        fi
        echo -e ""
    done
    
    IFS=',' read -ra CRT_INDEX <<< ${VALIDATED_CRT_TO_REVOKE:1}
    for element in "${CRT_INDEX[@]}"
    do
        CERT_SERIAL_NUMBER=${SERIAL_NUMBER_LIST[element]}
        CERTS_TO_REVOKE="$CERTS_TO_REVOKE,$CERT_SERIAL_NUMBER"
    done

    revoke-certificate ${CERTS_TO_REVOKE:1}

    cleanup-directory $CERTIFICATE_DATABASE_COPY_DIRECTORY
}

if [ $# == 0 ]; then
    exit 3
fi

if [[ " ${1} " == *"help"* ]] || [[ " ${1} " == *"--help"* ]]; then
    exit 3
else
    if [[ -z "$1" ]] || [[ -z "$2" ]] || [[ -z "$3" ]] || [[ -z "$4" ]]; then
        exit 3
    else
        service-certs-revoke-validate
        service-certs-revoke-execute
    fi 
fi